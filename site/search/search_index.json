{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kubernetes Contents What is Kubernetes Components Architecture Minikube and kubectl YAML configuration","title":"Introduction"},{"location":"#kubernetes","text":"","title":"Kubernetes"},{"location":"#contents","text":"What is Kubernetes Components Architecture Minikube and kubectl YAML configuration","title":"Contents"},{"location":"demo/spring-boot/mydemo/","text":"Simple spring boot kubernetes app Steps: Create and run the spring boot app locally Package the application run maven install. Check that .jar file is under target/myemo-0.0.1-SNAPSHOT.jar . Create a DockerFile and create an image from it EXPOSE the port number Test the docker image Push the docker image to the docker hub \"container repository\". Create a spring boot project Start the minikube minikube start Create the first pod kubectl create deployment my-demo-depl --image=yilmaznaslan/mydemo","title":"Spring-boot"},{"location":"demo/spring-boot/mydemo/#simple-spring-boot-kubernetes-app","text":"Steps: Create and run the spring boot app locally Package the application run maven install. Check that .jar file is under target/myemo-0.0.1-SNAPSHOT.jar . Create a DockerFile and create an image from it EXPOSE the port number Test the docker image Push the docker image to the docker hub \"container repository\".","title":"Simple spring boot kubernetes app"},{"location":"demo/spring-boot/mydemo/#create-a-spring-boot-project","text":"","title":"Create a spring boot project"},{"location":"demo/spring-boot/mydemo/#start-the-minikube","text":"minikube start","title":"Start the minikube"},{"location":"demo/spring-boot/mydemo/#create-the-first-pod","text":"kubectl create deployment my-demo-depl --image=yilmaznaslan/mydemo","title":"Create the first pod"},{"location":"demo/spring-boot/mydemo/HELP/","text":"Getting Started Reference Documentation For further reference, please consider the following sections: Official Apache Maven documentation Spring Boot Maven Plugin Reference Guide Create an OCI image Spring Web Guides The following guides illustrate how to use some features concretely: Building a RESTful Web Service Serving Web Content with Spring MVC Building REST services with Spring","title":"Getting Started"},{"location":"demo/spring-boot/mydemo/HELP/#getting-started","text":"","title":"Getting Started"},{"location":"demo/spring-boot/mydemo/HELP/#reference-documentation","text":"For further reference, please consider the following sections: Official Apache Maven documentation Spring Boot Maven Plugin Reference Guide Create an OCI image Spring Web","title":"Reference Documentation"},{"location":"demo/spring-boot/mydemo/HELP/#guides","text":"The following guides illustrate how to use some features concretely: Building a RESTful Web Service Serving Web Content with Spring MVC Building REST services with Spring","title":"Guides"},{"location":"demo/spring-boot/mydemo/bin/HELP/","text":"Getting Started Reference Documentation For further reference, please consider the following sections: Official Apache Maven documentation Spring Boot Maven Plugin Reference Guide Create an OCI image Spring Web Guides The following guides illustrate how to use some features concretely: Building a RESTful Web Service Serving Web Content with Spring MVC Building REST services with Spring","title":"Getting Started"},{"location":"demo/spring-boot/mydemo/bin/HELP/#getting-started","text":"","title":"Getting Started"},{"location":"demo/spring-boot/mydemo/bin/HELP/#reference-documentation","text":"For further reference, please consider the following sections: Official Apache Maven documentation Spring Boot Maven Plugin Reference Guide Create an OCI image Spring Web","title":"Reference Documentation"},{"location":"demo/spring-boot/mydemo/bin/HELP/#guides","text":"The following guides illustrate how to use some features concretely: Building a RESTful Web Service Serving Web Content with Spring MVC Building REST services with Spring","title":"Guides"},{"location":"tutorial/awsEks/","text":"AWS Elastic Kubernetes Service(EKS) What is EKS EKS is a managed kubernetes cluster that means AWS will manage the master nodes for you. It will create the master nodes. It will install all the necessary application on them like container tunme, kubernetes master proceses - it will scale and do the backups. If you have a small team of poeple then usually its a good idea to let the platform do this maintenane for you so you can focus on deploying your applications in kubernetes without worrying about whether masternodes are properly backed up etc. This means you can only create and worry about the worker nodes. How to use EKS In order to create a kuburnetes cluster you need to follow the following steps: Preparation steps Create AWS account Create a VPC Create an IAM Role with security user Create Cluster Control Plane Choose cluster name, k8s version Choose region and VPC for you cluster Set security for your cluster. Create Worker Node on AWS Worker nodes wil be EC 2 isntances with certain CPU , RAM and stroage resources. Create a Node Group(group of nodes) Choose cluster it will attach to Define Security Group Define max and min number of Nodes (Autoscaling)","title":"AWS EKS setup"},{"location":"tutorial/awsEks/#aws-elastic-kubernetes-serviceeks","text":"","title":"AWS Elastic Kubernetes Service(EKS)"},{"location":"tutorial/awsEks/#what-is-eks","text":"EKS is a managed kubernetes cluster that means AWS will manage the master nodes for you. It will create the master nodes. It will install all the necessary application on them like container tunme, kubernetes master proceses - it will scale and do the backups. If you have a small team of poeple then usually its a good idea to let the platform do this maintenane for you so you can focus on deploying your applications in kubernetes without worrying about whether masternodes are properly backed up etc. This means you can only create and worry about the worker nodes.","title":"What is EKS"},{"location":"tutorial/awsEks/#how-to-use-eks","text":"In order to create a kuburnetes cluster you need to follow the following steps: Preparation steps Create AWS account Create a VPC Create an IAM Role with security user Create Cluster Control Plane Choose cluster name, k8s version Choose region and VPC for you cluster Set security for your cluster. Create Worker Node on AWS Worker nodes wil be EC 2 isntances with certain CPU , RAM and stroage resources. Create a Node Group(group of nodes) Choose cluster it will attach to Define Security Group Define max and min number of Nodes (Autoscaling)","title":"How to use EKS"},{"location":"tutorial/part-1-architecture/","text":"Kubernetes Architecture Kubernetes cluster is made up with - at least one master node and - connected a couple of worker nodes, where each nod has a kubelet process running on it. Worker Node Worker nodes do the actual work where each node has multiple Pods on it. Processes 3 process must be installed on every node Container runtime Kubelet Kube proxy Kubelet Kubelet interacts with both the container and node .It is a service that actually runs the pods using the container runtime . Master Node Processes 4 process run on every master node ! 1. API Server 2. Scheduler 3. Controller manager 4. etcd API Server cluster gateway Acts as agtekeepr for authentication ! Scheduler Where to put the Pod ? Scheduler just decied on which Node new Pod should be scheduled. It is Kubelet that actually puts Node on a Controller Manager etcd etcd acts as a Clusterbrain. Cluster changes get stored in the key value store.","title":"Architecture"},{"location":"tutorial/part-1-architecture/#kubernetes-architecture","text":"Kubernetes cluster is made up with - at least one master node and - connected a couple of worker nodes, where each nod has a kubelet process running on it.","title":"Kubernetes Architecture"},{"location":"tutorial/part-1-architecture/#worker-node","text":"Worker nodes do the actual work where each node has multiple Pods on it.","title":"Worker Node"},{"location":"tutorial/part-1-architecture/#processes","text":"3 process must be installed on every node Container runtime Kubelet Kube proxy","title":"Processes"},{"location":"tutorial/part-1-architecture/#kubelet","text":"Kubelet interacts with both the container and node .It is a service that actually runs the pods using the container runtime .","title":"Kubelet"},{"location":"tutorial/part-1-architecture/#master-node","text":"","title":"Master Node"},{"location":"tutorial/part-1-architecture/#processes_1","text":"4 process run on every master node ! 1. API Server 2. Scheduler 3. Controller manager 4. etcd","title":"Processes"},{"location":"tutorial/part-1-architecture/#api-server","text":"cluster gateway Acts as agtekeepr for authentication !","title":"API Server"},{"location":"tutorial/part-1-architecture/#scheduler","text":"Where to put the Pod ? Scheduler just decied on which Node new Pod should be scheduled. It is Kubelet that actually puts Node on a","title":"Scheduler"},{"location":"tutorial/part-1-architecture/#controller-manager","text":"","title":"Controller Manager"},{"location":"tutorial/part-1-architecture/#etcd","text":"etcd acts as a Clusterbrain. Cluster changes get stored in the key value store.","title":"etcd"},{"location":"tutorial/part-2-components/","text":"Kubernetes Components When you deploy Kubernetes, you get a cluster . Basic components of a kubernetes cluster are Node & Pod Service & Ingress ConfigMap & Secret Volumes Deployment & statefulSet A Kubernetes cluster consists of a set of worker nodes that run containerized applications. Every cluster has at least one worker node. The worker node(s) host Pods that are the components of the application workload. The master node(s) manages the worker nodes and pods in the cluster. Node & pod Node Nodes contain pods which has container running environments. Node is simple server a physical or virtual machine Pod Smallest unit of K8s It creates running environment for containers. Basically it is a abstraction of container. You can run multiple containers in one pod but ussually 1 application container per Pod. Kubernetes offers a virtual network. That means each Pod gets itw own IP address not the continaer. So each Pod can communicate with each toher through these IP addresses(these are not public IP addresses.) Pods are ephemeral which means that they can die easly. When they die new ones will get created and will get a new IP address. Service & Ingres Pods communicate with each other using Service. Service has 2 functionality - Service is a static/permantent IP address that can be attached to each pod. Each pod will have its own service . - Service is also a load balancer which means that the service will actually catch the request and forward it to whichever part is least busy. - Lifecycle of Pod and Service is not connected. So even if the pods dies , the service and its IP adress will stay. Load balancer External Service External services that opens the communication from external sources. Internal Service But for databases, you don't want it to be open to the public requests. For such Pods you create internal services. Ingres A request first goes to Ingres which forwards to the service. ConfigMap & Secret ConfigMap External configuration of your application It usually contains configruation data such as DB URL. It is usually connected to the Pod so that pod gets the data that config map contains. ConfigMap is for non-confidential data only ! Secret It is just like ConfigMap but it is used to store secret data, credentials. It is stored not in plane text format but base64 coding format. Just like configMap you connect Pod to it so that Pod sees the data. Volume If the database container/pod restarts all the gets lost. - Storage on local machine - or remote outside of K8's cluster. Deployment & statefulSet Deplyoment If an application pod dies it would create a downtime where a user can not reach to application even in the production it can happen. The advantage of distributed systems and containers is instead of relying on just one applciation and one database, it is possible to replicate everything on multiple servers. In kubernetes you don't create replicas, you would define a blueprint so called \" Deployment \", which is another component of kubernetes. Layers of Abstruction: Deployment manages a replicaset RepilcaSet manages all the replicas of that pod Pod is an abstraction of a container Container Note : Everything below Deployment is handled by kubernetes. Note : Database pods can not be replicated using deployments , because dabase has a state which is its data. Meaning that if there are two replicas of the database the qould all need to access the same shared data storage ant there would need a mechanism that manages which pods are currently writing to that storage. Stateful Set So any Statefull application should be created using StatefulSet not Deployments . - StatefulSet's are just like deployments they take care of the repilcations - It is not a easy task to have statefulSet thats why it is common practice to host databases often outside of K8s cluster. K8s Level of Abstraction put here image or info","title":"Componenets"},{"location":"tutorial/part-2-components/#kubernetes-components","text":"When you deploy Kubernetes, you get a cluster . Basic components of a kubernetes cluster are Node & Pod Service & Ingress ConfigMap & Secret Volumes Deployment & statefulSet A Kubernetes cluster consists of a set of worker nodes that run containerized applications. Every cluster has at least one worker node. The worker node(s) host Pods that are the components of the application workload. The master node(s) manages the worker nodes and pods in the cluster.","title":"Kubernetes Components"},{"location":"tutorial/part-2-components/#node-pod","text":"","title":"Node &amp; pod"},{"location":"tutorial/part-2-components/#node","text":"Nodes contain pods which has container running environments. Node is simple server a physical or virtual machine","title":"Node"},{"location":"tutorial/part-2-components/#pod","text":"Smallest unit of K8s It creates running environment for containers. Basically it is a abstraction of container. You can run multiple containers in one pod but ussually 1 application container per Pod. Kubernetes offers a virtual network. That means each Pod gets itw own IP address not the continaer. So each Pod can communicate with each toher through these IP addresses(these are not public IP addresses.) Pods are ephemeral which means that they can die easly. When they die new ones will get created and will get a new IP address.","title":"Pod"},{"location":"tutorial/part-2-components/#service-ingres","text":"Pods communicate with each other using Service. Service has 2 functionality - Service is a static/permantent IP address that can be attached to each pod. Each pod will have its own service . - Service is also a load balancer which means that the service will actually catch the request and forward it to whichever part is least busy. - Lifecycle of Pod and Service is not connected. So even if the pods dies , the service and its IP adress will stay. Load balancer","title":"Service &amp; Ingres"},{"location":"tutorial/part-2-components/#external-service","text":"External services that opens the communication from external sources.","title":"External Service"},{"location":"tutorial/part-2-components/#internal-service","text":"But for databases, you don't want it to be open to the public requests. For such Pods you create internal services.","title":"Internal Service"},{"location":"tutorial/part-2-components/#ingres","text":"A request first goes to Ingres which forwards to the service.","title":"Ingres"},{"location":"tutorial/part-2-components/#configmap-secret","text":"","title":"ConfigMap &amp; Secret"},{"location":"tutorial/part-2-components/#configmap","text":"External configuration of your application It usually contains configruation data such as DB URL. It is usually connected to the Pod so that pod gets the data that config map contains. ConfigMap is for non-confidential data only !","title":"ConfigMap"},{"location":"tutorial/part-2-components/#secret","text":"It is just like ConfigMap but it is used to store secret data, credentials. It is stored not in plane text format but base64 coding format. Just like configMap you connect Pod to it so that Pod sees the data.","title":"Secret"},{"location":"tutorial/part-2-components/#volume","text":"If the database container/pod restarts all the gets lost. - Storage on local machine - or remote outside of K8's cluster.","title":"Volume"},{"location":"tutorial/part-2-components/#deployment-statefulset","text":"","title":"Deployment &amp; statefulSet"},{"location":"tutorial/part-2-components/#deplyoment","text":"If an application pod dies it would create a downtime where a user can not reach to application even in the production it can happen. The advantage of distributed systems and containers is instead of relying on just one applciation and one database, it is possible to replicate everything on multiple servers. In kubernetes you don't create replicas, you would define a blueprint so called \" Deployment \", which is another component of kubernetes. Layers of Abstruction: Deployment manages a replicaset RepilcaSet manages all the replicas of that pod Pod is an abstraction of a container Container Note : Everything below Deployment is handled by kubernetes. Note : Database pods can not be replicated using deployments , because dabase has a state which is its data. Meaning that if there are two replicas of the database the qould all need to access the same shared data storage ant there would need a mechanism that manages which pods are currently writing to that storage.","title":"Deplyoment"},{"location":"tutorial/part-2-components/#stateful-set","text":"So any Statefull application should be created using StatefulSet not Deployments . - StatefulSet's are just like deployments they take care of the repilcations - It is not a easy task to have statefulSet thats why it is common practice to host databases often outside of K8s cluster.","title":"Stateful Set"},{"location":"tutorial/part-2-components/#k8s-level-of-abstraction","text":"put here image or info","title":"K8s Level of Abstraction"},{"location":"tutorial/part-3-configuration/","text":"Kubernetes Configuration All the configuration in kubernetes cluster goes through a master node with the process called API Server . Configuration requests(yaml format) to the API SERVER which is the main entry point to the kubernetes Cluster can be established via three different Kubernetes clients which are. UI ( Kubernetes Dashboard) API (Script or curl command) CLI (kubectl) Configuration file format The format of the configruation files is .yaml where each configuration file has 3 parts . metadata specification status It is automatically generated and added by Kubernetes. Kubernetes will always the desired and actual state of that componenet. If they do not match, kubernetes will know that there is something to be fixed. K8s get the status data from etcd . Etcd hold at any time the current status of any kuberneted component and that's where the status information comes from. Attributes of \"spec\" are specific to the kind. Deployment configuration file Deployment is the blueprint for creating Pods . apiVersion: apps/v1 kind: Deployment metadata: name: my-app labels: app:my-app spec: replicas:2 selector: matchLabels: app:my-app template: metadata: labels: app: nginx spec: containers: - name_ nginx image: inginx:1.16 env: - name:SOME_ENV value:$SOME_ENV ports: - containerPort: 8080 Blueprint for pods spec > template : - Has its own metadata and spec section. - Applies to Pod. - What is the name of the container, which port it should open etc. spec: containers: - name_ nginx image: inginx:1.16 ports: - containerPort: 8080 Service configuration file apiVersion: v1 kind: Service metadata: name : nginx-service spec: selector: app: nginx ports: Secret Configuration File apiVersion: v1 kind: Secret metadata: name: mongodb-secret type: Opaque data: mongo-root-username: fasfasfasd mongo-rot-password: dgdsg34dad kind: Secret metadata/name: a random name type: \"opaque\" - default for arbitrar key-value paris data: the actual contents in the key-value pairs. Note: However the values in key/value pairs can not be plain text. They have to be echo -n '1234567' | base64 Notes: - Since the config file is going to be applied your application, it's a good practice to store the config file with your code.","title":"Configuration"},{"location":"tutorial/part-3-configuration/#kubernetes-configuration","text":"All the configuration in kubernetes cluster goes through a master node with the process called API Server . Configuration requests(yaml format) to the API SERVER which is the main entry point to the kubernetes Cluster can be established via three different Kubernetes clients which are. UI ( Kubernetes Dashboard) API (Script or curl command) CLI (kubectl)","title":"Kubernetes Configuration"},{"location":"tutorial/part-3-configuration/#configuration-file-format","text":"The format of the configruation files is .yaml where each configuration file has 3 parts . metadata specification status It is automatically generated and added by Kubernetes. Kubernetes will always the desired and actual state of that componenet. If they do not match, kubernetes will know that there is something to be fixed. K8s get the status data from etcd . Etcd hold at any time the current status of any kuberneted component and that's where the status information comes from. Attributes of \"spec\" are specific to the kind.","title":"Configuration file format"},{"location":"tutorial/part-3-configuration/#deployment-configuration-file","text":"Deployment is the blueprint for creating Pods . apiVersion: apps/v1 kind: Deployment metadata: name: my-app labels: app:my-app spec: replicas:2 selector: matchLabels: app:my-app template: metadata: labels: app: nginx spec: containers: - name_ nginx image: inginx:1.16 env: - name:SOME_ENV value:$SOME_ENV ports: - containerPort: 8080","title":"Deployment configuration file"},{"location":"tutorial/part-3-configuration/#blueprint-for-pods","text":"spec > template : - Has its own metadata and spec section. - Applies to Pod. - What is the name of the container, which port it should open etc. spec: containers: - name_ nginx image: inginx:1.16 ports: - containerPort: 8080","title":"Blueprint for pods"},{"location":"tutorial/part-3-configuration/#service-configuration-file","text":"apiVersion: v1 kind: Service metadata: name : nginx-service spec: selector: app: nginx ports:","title":"Service configuration file"},{"location":"tutorial/part-3-configuration/#secret-configuration-file","text":"apiVersion: v1 kind: Secret metadata: name: mongodb-secret type: Opaque data: mongo-root-username: fasfasfasd mongo-rot-password: dgdsg34dad kind: Secret metadata/name: a random name type: \"opaque\" - default for arbitrar key-value paris data: the actual contents in the key-value pairs. Note: However the values in key/value pairs can not be plain text. They have to be echo -n '1234567' | base64 Notes: - Since the config file is going to be applied your application, it's a good practice to store the config file with your code.","title":"Secret Configuration File"},{"location":"tutorial/part-4-minikube_kubectl/","text":"Minikube & Kubectl Usually in kubernetes work, when you set up a production cluster it will consists of Multiple Master and Worker Nodes, where each node represents a virtuel or physical machine. So if you want to test something on your local environment or if you want to try somehtng out very quickly for example deploying a new application, setting up a cluster like this would be imposible if you don't have the enough resources such as CPU, RAM etc. Exactly for this use-case there is opensource tool called Minikube . Minikube Minikube is a one Noe cluster where master and worker node processes run on one node and this node will have a docker runtime environment pre-installed to able to trun the containers/pods Creates Virtual Box on your laptop Node runs in that Virtual Box 1 Node K8s cluster for testing purposes Minikube has a docker pre-installed. Kubectl Now you have virtal node on your local machne represnets the minikube. kubectl is the way to communiate the kuberentes cluster/ API Server. Kubectl is used to communicate with any type of cluster minicube cluster or cloud cluster. An important thing here to note is that Kubectl is not only used for Minikue Cluster . It is the tool to use interact with any type of Kubernetes Cluster setup such as Cloud Cluster, Hybrid Cluster of Miniube cluster. Commands CRUD commands Create Pod/Deployment Note: In kubernetes you don't actually create Pods, but you create deployments. Deployments are abstracturn over Pods Usage kubectl create deployment NAME --image=image Example kubectl create deployment nginx-depl --image=nginx Info when you create a deplyoemtn there are lots of options to enter. In practicaly the way to do that is using config files using apply Edit sdeployment kubectl edit deployment nginx-depl returns auto generated configuration file with default values. Delete Deployment kubectl delete deployment mongo-depl kubectl delete -f nginx-service.yaml Status of different K8s componenets kubectl get nodes - Everythins runs on master node. kubectl get services kubectl get deployment kubectl get pod kubectl get replicaset kubectl get deployment nginx-deployment -o yaml kubectl get deployment nginx-deployment -o yaml > nginx-deployment-result.yaml kubectl get namespace Debugging pods kubectl describe xxxx kubectl logs kubectl exec -it mongo-depl-333434 -- bin/bash Use configuration file for CRUD kubectl apply -f nginx-deployment.yaml Installation Minikube needs virtualization because it is going to run in a virtual box setup or some hypervisor. 1. Install Hypervisor - Hyperkit, VirtualBox - 2. Install Minicube - brew install minikube`` Start up Tell Minikube which Hypervisor it should use. minikube start --vm-driver=hyperkit Now kubectl is now configured to use 'minikube', which means the minikube cluster is set up and kubectl command is also connected with the minikube cluster to interact with it. Check if the kubectl is running minikube status kubectl get nodes kubectl version","title":"Minikube&Kubectl"},{"location":"tutorial/part-4-minikube_kubectl/#minikube-kubectl","text":"Usually in kubernetes work, when you set up a production cluster it will consists of Multiple Master and Worker Nodes, where each node represents a virtuel or physical machine. So if you want to test something on your local environment or if you want to try somehtng out very quickly for example deploying a new application, setting up a cluster like this would be imposible if you don't have the enough resources such as CPU, RAM etc. Exactly for this use-case there is opensource tool called Minikube .","title":"Minikube &amp; Kubectl"},{"location":"tutorial/part-4-minikube_kubectl/#minikube","text":"Minikube is a one Noe cluster where master and worker node processes run on one node and this node will have a docker runtime environment pre-installed to able to trun the containers/pods Creates Virtual Box on your laptop Node runs in that Virtual Box 1 Node K8s cluster for testing purposes Minikube has a docker pre-installed.","title":"Minikube"},{"location":"tutorial/part-4-minikube_kubectl/#kubectl","text":"Now you have virtal node on your local machne represnets the minikube. kubectl is the way to communiate the kuberentes cluster/ API Server. Kubectl is used to communicate with any type of cluster minicube cluster or cloud cluster. An important thing here to note is that Kubectl is not only used for Minikue Cluster . It is the tool to use interact with any type of Kubernetes Cluster setup such as Cloud Cluster, Hybrid Cluster of Miniube cluster.","title":"Kubectl"},{"location":"tutorial/part-4-minikube_kubectl/#commands","text":"","title":"Commands"},{"location":"tutorial/part-4-minikube_kubectl/#crud-commands","text":"","title":"CRUD commands"},{"location":"tutorial/part-4-minikube_kubectl/#create-poddeployment","text":"Note: In kubernetes you don't actually create Pods, but you create deployments. Deployments are abstracturn over Pods","title":"Create Pod/Deployment"},{"location":"tutorial/part-4-minikube_kubectl/#usage","text":"kubectl create deployment NAME --image=image","title":"Usage"},{"location":"tutorial/part-4-minikube_kubectl/#example","text":"kubectl create deployment nginx-depl --image=nginx","title":"Example"},{"location":"tutorial/part-4-minikube_kubectl/#info","text":"when you create a deplyoemtn there are lots of options to enter. In practicaly the way to do that is using config files using apply","title":"Info"},{"location":"tutorial/part-4-minikube_kubectl/#edit-sdeployment","text":"kubectl edit deployment nginx-depl returns auto generated configuration file with default values.","title":"Edit sdeployment"},{"location":"tutorial/part-4-minikube_kubectl/#delete-deployment","text":"kubectl delete deployment mongo-depl kubectl delete -f nginx-service.yaml","title":"Delete Deployment"},{"location":"tutorial/part-4-minikube_kubectl/#status-of-different-k8s-componenets","text":"kubectl get nodes - Everythins runs on master node. kubectl get services kubectl get deployment kubectl get pod kubectl get replicaset kubectl get deployment nginx-deployment -o yaml kubectl get deployment nginx-deployment -o yaml > nginx-deployment-result.yaml kubectl get namespace","title":"Status of different K8s componenets"},{"location":"tutorial/part-4-minikube_kubectl/#debugging-pods","text":"kubectl describe xxxx kubectl logs kubectl exec -it mongo-depl-333434 -- bin/bash","title":"Debugging pods"},{"location":"tutorial/part-4-minikube_kubectl/#use-configuration-file-for-crud","text":"kubectl apply -f nginx-deployment.yaml","title":"Use configuration file for CRUD"},{"location":"tutorial/part-4-minikube_kubectl/#installation","text":"Minikube needs virtualization because it is going to run in a virtual box setup or some hypervisor. 1. Install Hypervisor - Hyperkit, VirtualBox - 2. Install Minicube - brew install minikube``","title":"Installation"},{"location":"tutorial/part-4-minikube_kubectl/#start-up","text":"Tell Minikube which Hypervisor it should use. minikube start --vm-driver=hyperkit Now kubectl is now configured to use 'minikube', which means the minikube cluster is set up and kubectl command is also connected with the minikube cluster to interact with it. Check if the kubectl is running minikube status kubectl get nodes kubectl version","title":"Start up"}]}